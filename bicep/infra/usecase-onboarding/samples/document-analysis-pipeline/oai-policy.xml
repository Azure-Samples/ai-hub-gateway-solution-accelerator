<!--
    Azure OpenAI Product Policy for Document Summarization
    
    This policy enforces:
    - Model restrictions optimized for document processing
    - Token limits for large document summarization
    - Batch processing support
    - Cost optimization with model routing
-->
<policies>
    <inbound>
        <base />
        
        <!-- Extract and validate model -->
        <include-fragment fragment-id="set-llm-requested-model" />
        
        <!-- Extract task type for model routing -->
        <set-variable name="taskType" value="@(context.Request.Headers.GetValueOrDefault("X-Task-Type", "summarize"))" />
        
        <!-- Model restrictions: Optimized for document tasks -->
        <!-- Allowed: GPT-4o (complex), GPT-4o-mini (simple), GPT-4-turbo (batch) -->
        <choose>
            <when condition="@(!new [] { "gpt-4o", "gpt-4o-mini", "gpt-4-turbo" }.Contains(context.Variables["requestedModel"] ?? ""))">
                <return-response>
                    <set-status code="403" reason="Forbidden" />
                    <set-header name="Content-Type" exists-action="override">
                        <value>application/json</value>
                    </set-header>
                    <set-body>@{
                        return new JObject(
                            new JProperty(&quot;error&quot;, new JObject(
                                new JProperty(&quot;code&quot;, &quot;ModelNotAllowed&quot;),
                                new JProperty(&quot;message&quot;, &quot;Allowed models for document processing: gpt-4o, gpt-4o-mini, gpt-4-turbo&quot;)
                            ))
                        ).ToString();
                    }</set-body>
                </return-response>
            </when>
        </choose>
        
        <!-- Task-based rate limiting -->
        <choose>
            <!-- Batch processing: Lower per-minute limit but higher daily quota -->
            <when condition="@(context.Variables.GetValueOrDefault&lt;string&gt;(&quot;taskType&quot;) == &quot;batch&quot;)">
                <rate-limit-by-key calls="100" renewal-period="60" counter-key="@(context.Subscription.Id + &quot;-batch&quot;)" />
                <quota-by-key calls="100000" renewal-period="86400" counter-key="@(context.Subscription.Id + &quot;-batch-daily&quot;)" />
            </when>
            <!-- Real-time processing: Higher per-minute limit -->
            <otherwise>
                <rate-limit-by-key calls="200" renewal-period="60" counter-key="@(context.Subscription.Id)" />
                <quota-by-key calls="50000" renewal-period="86400" counter-key="@(context.Subscription.Id + &quot;-daily&quot;)" />
            </otherwise>
        </choose>
        
        <!-- Token limit validation for large documents -->
        <set-variable name="maxTokens" value="@{
            var body = context.Request.Body?.As&lt;JObject&gt;(preserveContent: true);
            return body?[&quot;max_tokens&quot;]?.Value&lt;int&gt;() ?? 2000;
        }" />
        
        <choose>
            <when condition="@(context.Variables.GetValueOrDefault&lt;int&gt;(&quot;maxTokens&quot;) &gt; 16000)">
                <return-response>
                    <set-status code="400" reason="Bad Request" />
                    <set-header name="Content-Type" exists-action="override">
                        <value>application/json</value>
                    </set-header>
                    <set-body>@{
                        return new JObject(
                            new JProperty(&quot;error&quot;, new JObject(
                                new JProperty(&quot;code&quot;, &quot;MaxTokensExceeded&quot;),
                                new JProperty(&quot;message&quot;, &quot;Maximum tokens limit is 16000 for document processing&quot;)
                            ))
                        ).ToString();
                    }</set-body>
                </return-response>
            </when>
        </choose>
        
        <!-- Add tracking headers -->
        <set-header name="X-Request-Id" exists-action="override">
            <value>@(Guid.NewGuid().ToString())</value>
        </set-header>
        
        <set-variable name="requestStartTime" value="@(DateTime.UtcNow)" />
        
    </inbound>
    
    <backend>
        <base />
    </backend>
    
    <outbound>
        <base />
        
        <!-- Extract token usage for cost tracking -->
        <set-variable name="responseBody" value="@(context.Response.Body.As&lt;JObject&gt;(preserveContent: true))" />
        <set-variable name="usage" value="@{
            var response = context.Variables.GetValueOrDefault&lt;JObject&gt;(&quot;responseBody&quot;);
            return response?[&quot;usage&quot;];
        }" />
        
        <!-- Add detailed usage headers -->
        <set-header name="X-Tokens-Prompt" exists-action="override">
            <value>@{
                var usage = context.Variables.GetValueOrDefault&lt;JToken&gt;(&quot;usage&quot;);
                return usage?[&quot;prompt_tokens&quot;]?.ToString() ?? &quot;0&quot;;
            }</value>
        </set-header>
        
        <set-header name="X-Tokens-Completion" exists-action="override">
            <value>@{
                var usage = context.Variables.GetValueOrDefault&lt;JToken&gt;(&quot;usage&quot;);
                return usage?[&quot;completion_tokens&quot;]?.ToString() ?? &quot;0&quot;;
            }</value>
        </set-header>
        
        <set-header name="X-Tokens-Total" exists-action="override">
            <value>@{
                var usage = context.Variables.GetValueOrDefault&lt;JToken&gt;(&quot;usage&quot;);
                return usage?[&quot;total_tokens&quot;]?.ToString() ?? &quot;0&quot;;
            }</value>
        </set-header>
        
        <!-- Add cost estimate header (approximate) -->
        <set-header name="X-Estimated-Cost-USD" exists-action="override">
            <value>@{
                var usage = context.Variables.GetValueOrDefault&lt;JToken&gt;(&quot;usage&quot;);
                var totalTokens = usage?[&quot;total_tokens&quot;]?.Value&lt;double&gt;() ?? 0;
                var model = context.Variables.GetValueOrDefault&lt;string&gt;(&quot;requestedModel&quot;, &quot;&quot;);
                
                // Approximate pricing per 1K tokens
                var pricePerK = model.Contains(&quot;gpt-4o-mini&quot;) ? 0.00015 : 
                                model.Contains(&quot;gpt-4o&quot;) ? 0.0025 : 0.01;
                
                var cost = (totalTokens / 1000.0) * pricePerK;
                return cost.ToString(&quot;F6&quot;);
            }</value>
        </set-header>
        
        <!-- Add metadata headers -->
        <set-header name="X-UseCase" exists-action="override">
            <value>Operations-DocAnalysisPipeline</value>
        </set-header>
        
        <set-header name="X-Task-Type" exists-action="override">
            <value>@(context.Variables.GetValueOrDefault&lt;string&gt;(&quot;taskType&quot;, &quot;summarize&quot;))</value>
        </set-header>
        
        <set-header name="X-Processing-Time-Ms" exists-action="override">
            <value>@{
                var startTime = context.Variables.GetValueOrDefault&lt;DateTime&gt;(&quot;requestStartTime&quot;);
                return ((DateTime.UtcNow - startTime).TotalMilliseconds).ToString(&quot;F0&quot;);
            }</value>
        </set-header>
        
    </outbound>
    
    <on-error>
        <base />
        
        <!-- Enhanced error handling -->
        <set-body>@{
            var error = context.LastError;
            var requestId = context.Request.Headers.GetValueOrDefault(&quot;X-Request-Id&quot;, &quot;unknown&quot;);
            var taskType = context.Variables.GetValueOrDefault&lt;string&gt;(&quot;taskType&quot;, &quot;unknown&quot;);
            
            return new JObject(
                new JProperty(&quot;error&quot;, new JObject(
                    new JProperty(&quot;code&quot;, error?.Source ?? &quot;SummarizationError&quot;),
                    new JProperty(&quot;message&quot;, error?.Message ?? &quot;Failed to process document summarization&quot;),
                    new JProperty(&quot;requestId&quot;, requestId),
                    new JProperty(&quot;taskType&quot;, taskType),
                    new JProperty(&quot;timestamp&quot;, DateTime.UtcNow.ToString(&quot;o&quot;))
                ))
            ).ToString();
        }</set-body>
        
    </on-error>
</policies>
