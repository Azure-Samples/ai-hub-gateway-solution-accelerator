<!--
    Document Intelligence Product Policy
    
    This policy enforces:
    - Higher rate limits for batch document processing
    - Document type routing and validation
    - Long-running operation handling
    - File size restrictions
-->
<policies>
    <inbound>
        <base />
        
        <!-- Extract document type from header or path -->
        <set-variable name="documentType" value="@(context.Request.Headers.GetValueOrDefault(&quot;X-Document-Type&quot;, &quot;general&quot;))" />
        
        <!-- Validate document type -->
        <choose>
            <when condition="@(!new [] { &quot;invoice&quot;, &quot;receipt&quot;, &quot;contract&quot;, &quot;identity&quot;, &quot;general&quot;, &quot;layout&quot; }.Contains(context.Variables.GetValueOrDefault&lt;string&gt;(&quot;documentType&quot;, &quot;&quot;)))">
                <return-response>
                    <set-status code="400" reason="Bad Request" />
                    <set-header name="Content-Type" exists-action="override">
                        <value>application/json</value>
                    </set-header>
                    <set-body>@{
                        return new JObject(
                            new JProperty(&quot;error&quot;, new JObject(
                                new JProperty(&quot;code&quot;, &quot;InvalidDocumentType&quot;),
                                new JProperty(&quot;message&quot;, &quot;Allowed document types: invoice, receipt, contract, identity, general, layout&quot;)
                            ))
                        ).ToString();
                    }</set-body>
                </return-response>
            </when>
        </choose>
        
        <!-- Higher rate limits for document processing pipeline -->
        <!-- 500 requests per minute for batch processing -->
        <rate-limit-by-key calls="500" renewal-period="60" counter-key="@(context.Subscription.Id)" />
        
        <!-- Daily quota: 50,000 documents -->
        <quota-by-key calls="50000" renewal-period="86400" counter-key="@(context.Subscription.Id + &quot;-daily&quot;)" />
        
        <!-- Add request correlation ID -->
        <set-header name="X-Request-Id" exists-action="override">
            <value>@(Guid.NewGuid().ToString())</value>
        </set-header>
        
        <!-- Add timestamp for processing time tracking -->
        <set-variable name="requestStartTime" value="@(DateTime.UtcNow)" />
        
        <!-- Set timeout for long-running operations -->
        <timeout timeout="120" />
        
    </inbound>
    
    <backend>
        <base />
        
        <!-- Retry logic for transient failures -->
        <retry condition="@(context.Response.StatusCode == 429 || context.Response.StatusCode &gt;= 500)" count="3" interval="2" delta="1" max-interval="10">
            <set-header name="X-Retry-Attempt" exists-action="override">
                <value>@(context.Variables.GetValueOrDefault&lt;int&gt;(&quot;retryCount&quot;, 0).ToString())</value>
            </set-header>
            <set-variable name="retryCount" value="@(context.Variables.GetValueOrDefault&lt;int&gt;(&quot;retryCount&quot;, 0) + 1)" />
        </retry>
        
    </backend>
    
    <outbound>
        <base />
        
        <!-- Add processing metadata -->
        <set-header name="X-UseCase" exists-action="override">
            <value>Operations-DocAnalysisPipeline</value>
        </set-header>
        
        <set-header name="X-Document-Type" exists-action="override">
            <value>@(context.Variables.GetValueOrDefault&lt;string&gt;(&quot;documentType&quot;, &quot;general&quot;))</value>
        </set-header>
        
        <!-- Calculate processing time -->
        <set-header name="X-Processing-Time-Ms" exists-action="override">
            <value>@{
                var startTime = context.Variables.GetValueOrDefault&lt;DateTime&gt;(&quot;requestStartTime&quot;);
                return ((DateTime.UtcNow - startTime).TotalMilliseconds).ToString(&quot;F0&quot;);
            }</value>
        </set-header>
        
        <!-- Add operation location for async operations -->
        <choose>
            <when condition="@(context.Response.StatusCode == 202)">
                <set-variable name="operationLocation" value="@(context.Response.Headers.GetValueOrDefault(&quot;Operation-Location&quot;, &quot;&quot;))" />
            </when>
        </choose>
        
    </outbound>
    
    <on-error>
        <base />
        
        <!-- Enhanced error handling for document processing -->
        <set-body>@{
            var error = context.LastError;
            var requestId = context.Request.Headers.GetValueOrDefault(&quot;X-Request-Id&quot;, &quot;unknown&quot;);
            var documentType = context.Variables.GetValueOrDefault&lt;string&gt;(&quot;documentType&quot;, &quot;unknown&quot;);
            
            return new JObject(
                new JProperty(&quot;error&quot;, new JObject(
                    new JProperty(&quot;code&quot;, error?.Source ?? &quot;DocumentProcessingError&quot;),
                    new JProperty(&quot;message&quot;, error?.Message ?? &quot;Failed to process document&quot;),
                    new JProperty(&quot;requestId&quot;, requestId),
                    new JProperty(&quot;documentType&quot;, documentType),
                    new JProperty(&quot;timestamp&quot;, DateTime.UtcNow.ToString(&quot;o&quot;))
                ))
            ).ToString();
        }</set-body>
        
        <set-header name="Content-Type" exists-action="override">
            <value>application/json</value>
        </set-header>
        
    </on-error>
</policies>
